import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
import config from '../../config.jsx';

const FinalcostingContext = createContext();

export const useFinalcosting = () => {
  const context = useContext(FinalcostingContext);
  if (!context) {
    throw new Error('useFinalcosting must be used within a FinalcostingProvider');
  }
  return context;
};

export const FinalcostingProvider = ({ children }) => {
  const [historyy, setHistoryy] = useState([]);
  const [marginss, setMargins] = useState([]);
  const [addData, setAddData] = useState([]);
  const [loadings, setLoadings] = useState(false);
  const[ loadingss, setLoadingss ] = useState(false);
  const[ loadingsss, setLoadingsss ] = useState(false);
  const [error, setError] = useState(null);
  const [downloadCounts, setDownloadCounts] = useState({});

  // Get user from localStorage
  const getUserFromStorage = () => {
    try {
      const userStr = localStorage.getItem('persist:root');
      if (!userStr) return null;

      const parsed = JSON.parse(userStr);
      const userState = JSON.parse(parsed.user);
      return userState.currentUser;
    } catch (error) {
      console.error('Error getting user from localStorage:', error);
      return null;
    }
  };

  // Fetch ALL final costing history and margins with automatic pagination
  const fetchAllFinalcostingData = useCallback(async () => {
    try {
      setLoadingsss(true);
      setError(null);

      // Fetch ALL history data with automatic pagination
      let allHistoryData = [];
      let currentPage = 1;
      let hasMorePages = true;
      const pageSize = 5; // You can adjust this based on your backend default

      while (hasMorePages) {
        const historyResponse = await fetch(
          `${config.API_HOST}/api/finalcosting/get?page=${currentPage}&limit=${pageSize}`
        );
        
        if (!historyResponse.ok) {
          throw new Error("Failed to fetch history");
        }
        
        const historyData = await historyResponse.json();
        
        // Add current page data to the accumulated data
        if (historyData?.operations?.length > 0) {
          allHistoryData = [...allHistoryData, ...historyData.operations];
        }
        
        // Check if we have more pages to fetch
        if (historyData?.pagination) {
          hasMorePages = currentPage < historyData.pagination.totalPages;
          currentPage++;
        } else {
          // If no pagination info, check if we got less data than requested
          hasMorePages = historyData?.operations?.length === pageSize;
          currentPage++;
        }
        
        // Safety check to prevent infinite loops
        if (currentPage > 1000) {
          console.warn("Reached maximum page limit (1000), stopping pagination");
          break;
        }
      }
      
      
      // Set ALL accumulated data
      setHistoryy(allHistoryData);

      // Fetch margins data (assuming this doesn't need pagination)
      const marginsResponse = await fetch(
        `${config.API_HOST}/api/margin/get-margin`
      );
      
      if (!marginsResponse.ok) {
        throw new Error("Failed to fetch margins");
      }
      
      const marginsData = await marginsResponse.json();
      setMargins(marginsData || []);

    } catch (error) {
      console.error("Error fetching all data:", error);
      setError(error.message);
      setHistoryy([]);
      setMargins([]);
    } finally {
      setLoadingsss(false);
    }
  }, []);

  // Create new finalcosting entry
  const createFinalcosting = useCallback(async (historyItem) => {
    try {
      setLoadingsss(true);
      setError(null);

      const response = await fetch(
        `${config.API_HOST}/api/finalcosting/create`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(historyItem),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to save history");
      }

      const result = await response.json();
      
      // Add the new item to the history
      setHistoryy(prev => [...prev, result]);
      
      return result;
    } catch (error) {
      console.error("Error creating finalcosting:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadingsss(false);
    }
  }, []);

  // Delete finalcosting entry
  const deleteFinalcosting = useCallback(async (historyId) => {
    try {
      setLoadingsss(true);
      setError(null);

      const response = await fetch(
        `${config.API_HOST}/api/finalcosting/delete/${historyId}`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error("Failed to delete history");
      }

      // Remove the item from history
      setHistoryy(prev => prev.filter((item) => item._id !== historyId));
      
      return true;
    } catch (error) {
      console.error("Error deleting finalcosting:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadingsss(false);
    }
  }, []);

  // Update finalcosting entry (convert quote)
  const updateFinalcosting = useCallback(async (historyId, updateData) => {
    try {
      setLoadingsss(true);
      setError(null);

      const response = await fetch(
        `${config.API_HOST}/api/finalcosting/update-entire/${historyId}`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updateData),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to update history");
      }

      const result = await response.json();
      
      // Update the item in history
      setHistoryy(prev => prev.map(item => 
        item._id === historyId ? { ...item, ...updateData } : item
      ));
      
      return result;
    } catch (error) {
      console.error("Error updating finalcosting:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadingsss(false);
    }
  }, []);

  // Track download
  const trackDownload = useCallback(async (packageId, packageName, downloadType ,history) => {
   console.log("history", history);
    try {
      // Verify this is the first history item
      const firstHistory = history.length > 0 ? history[0] : null;
      if (!firstHistory || firstHistory._id !== packageId) {
        return null; // Don't track if not first history
      }

      const name = packageName.packageName;
      const currentDate = new Date();
      const currentUser = getUserFromStorage();
      
      const response = await fetch(`${config.API_HOST}/api/packagetracker/track`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          packageId,
          packageName: name,
          downloadType,
          user: {
            id: currentUser?.data?._id || 'anonymous',
            name: `${currentUser?.data?.firstName || ''} ${currentUser?.data?.lastName || ''}`.trim() || 'Anonymous User',
            email: currentUser?.data?.email || null,
            userType: currentUser?.data?.userType || null,
            marginPercentage: history[0]?.marginPercentage || null,
            marginAmount: history[0]?.finalTotal || null,
            leaddetails: history[0]?.transfer?.selectedLead || null,
            state: history[0]?.transfer?.state|| null,
            travelDate: history[0]?.transfer?.selectedLead?.travelDate|| null
          },
          timestamp: currentDate.toISOString(),
          downloadDate: currentDate.toLocaleDateString()
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to track download");
      }
console.log("response", response);
      const result = await response.json();
      console.log("result", result);
      // Update local download counts only for first history
      setDownloadCounts(prev => ({
        ...prev,
        [packageId]: result.downloadCounts
      }));

      return result;
    } catch (error) {
      console.error('Error tracking download:', error);
      setError(error.message);
      throw error;
    }
  }, [historyy]);
  function capitalizeWords(str) {
    return str.replace(/\b\w/g, char => char.toUpperCase());
  }
  // Request edit discount
  const requestEditDiscount = useCallback(async (packageId, packageName, discountPercentage, state, packageSummary, marginAmount, marginPercentage) => {
         // Get the package state and extract just the state name
         const packageState = capitalizeWords(state.toLowerCase());
      
    try {
      setLoadings(true);
      setError(null);
console.log("state", state);
      const currentUser = getUserFromStorage();
      console.log("currentUser", currentUser);
      const response = await fetch(`${config.API_HOST}/api/margin/update-edit-discount/${packageState}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          editDiscount: [{
            packageId: packageId,
            packageName: packageName,
            package: {
              ...packageSummary,
              marginAmount: marginAmount,
              marginPercentage: marginPercentage
            },
            loginUserDetail: {
              userId: currentUser?.data?._id || 'anonymous',
              username: `${currentUser?.data?.firstName || ''} ${currentUser?.data?.lastName || ''}`.trim() || 'Anonymous User',
              role: currentUser?.data?.userType || 'user',
              managerName: currentUser?.data?.managerName || 'No Manager',
              companyName: currentUser?.data?.companyName || 'No Company'
            },
            discountPercentage: discountPercentage,
            accept: "",
            managerName: currentUser?.data?.managerName || 'No Manager'
          }]
        }),
      });

      if (!response.ok) {
        if (response.status === 404) {
          // Backend route not implemented yet - show temporary message
          console.warn("Edit discount backend route not implemented yet");
          return {
            success: true,
            message: "Edit discount request feature is being implemented. Your request has been logged locally.",
            temporary: true
          };
        }
        throw new Error("Failed to request edit discount");
      }

      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error requesting edit discount:', error);
      setError(error.message);
      throw error;
    } finally {
      setLoadings(false);
    }
  }, []);



  // Fetch margins by state
  const fetchMarginByState = useCallback(async (state) => {
    try {
      setLoadings(true);
      setError(null);

      const response = await fetch(
        `${config.API_HOST}/api/margin/get-margin`
      );
      
      if (!response.ok) {
        throw new Error("Failed to fetch margins");
      }
      
      const data = await response.json();
      
      // Get the package state and extract just the state name
      const packageState = state.toLowerCase();
      
      // Find matching state margin
      const matchingStateMargin = data?.data?.find(
        (margin) => (margin.state || "").toLowerCase() == packageState
      );

      return matchingStateMargin || (Array.isArray(data.data) ? data.data[0] : null);
    } catch (error) {
      console.error("Error fetching margin by state:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadings(false);
    }
  }, []);

  // Fetch data from /api/add/get/ endpoint
  const fetchAddData = useCallback(async () => {
    try {
      setLoadingss(true);
      setError(null);

      const response = await fetch(`${config.API_HOST}/api/add/get`);
      
      if (!response.ok) {
        throw new Error("Failed to fetch add data");
      }
      
      const data = await response.json();
      
      setAddData(data);
      return data;
    } catch (error) {
      console.error("Error fetching add data:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadingss(false);
    }
  }, []);

  // Delete package function
  const deletePackage = useCallback(async (packageId) => {
    try {
      setLoadings(true);
      setError(null);

      const response = await fetch(`${config.API_HOST}/api/add/delete/${packageId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to delete package");
      }

      // Remove the package from addData
      setAddData(prev => prev.filter(pkg => pkg._id !== packageId));
      
      return true;
    } catch (error) {
      console.error("Error deleting package:", error);
      setError(error.message);
      throw error;
    } finally {
      setLoadings(false);
    }
  }, []);

  // Fetch data when provider mounts
  useEffect(() => {
    fetchAllFinalcostingData();
    fetchAddData();
  }, [fetchAllFinalcostingData]);

  // Clear error
  const clearError = () => setError(null);

  // Refresh data function
  const refreshData = () => {
    fetchAllFinalcostingData();
    fetchAddData();
  };

  const contextValue = {
    // State - ALL data
    historyy, // Contains ALL history data
    marginss,  // Contains ALL margins data
    addData,   // Contains add data
    loadings,
    loadingss,
    loadingsss,
    error,
    downloadCounts,
    
    // Actions
    fetchAllFinalcostingData,
    createFinalcosting,
    deleteFinalcosting,
    updateFinalcosting,
    trackDownload,
    requestEditDiscount,
    fetchMarginByState,
    fetchAddData,
    deletePackage,
    refreshData,
    clearError,
    setHistoryy,
    setMargins,
    setAddData,
  };

  return (
    <FinalcostingContext.Provider value={contextValue}>
      {children}
    </FinalcostingContext.Provider>
  );
};

export default FinalcostingContext; 